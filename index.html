<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D星空粒子交互系统</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #video { position: absolute; top: 0; left: 0; width: 320px; height: 240px; opacity: 0.3; z-index: 1; }
        #error { position: absolute; top: 10px; right: 10px; color: red; z-index: 2; font-family: Arial; }
        #debug { position: absolute; bottom: 10px; left: 10px; color: white; z-index: 2; font-family: Arial; font-size: 12px; }
    </style>
</head>
<body>
    <video id="video" autoplay muted playsinline></video>
    <div id="error"></div>
    <div id="debug"></div>
    <canvas id="canvas"></canvas>

    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const videoElement = document.getElementById('video');
        const errorDiv = document.getElementById('error');
        const debugDiv = document.getElementById('debug');
        const canvasElement = document.getElementById('canvas');

        // WebGL检查 & 强制WebGL1（安卓Chrome WebGL2 bug修复）
        const gl = canvasElement.getContext('webgl', { alpha: false }); // WebGL1
        if (!gl) {
            errorDiv.textContent = 'WebGL1不支持！更新浏览器。';
        }

        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvasElement, 
            context: gl, // 强制用WebGL1上下文
            antialias: false,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // 降到1.5，防高DPI粒子缩水
        renderer.setClearColor(0x000011); // 深蓝星空

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15; // 拉近，确保视锥覆盖

        // 测试盒子：红色立方体，确认渲染
        const boxGeometry = new THREE.BoxGeometry(8, 8, 8);
        const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(0, 0, -5); // 放相机前
        scene.add(box);

        // 粒子（巨型，位置全相机前）
        const particleCount = 2000; // 再减，防内存
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 10.0, // 超大size
            sizeAttenuation: false, // 恒定大小
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending // 辉光效果
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // 初始化粒子（z全负，确保相机前）
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 40;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 40;
            positions[i * 3 + 2] = -10 - Math.random() * 20; // z: -10 to -30
            velocities[i * 3] = (Math.random() - 0.5) * 0.1;
            velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
            velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.05; // z慢点
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // 文字点云（调整z负）
        function generateTextPoints(text, count) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 60px "Microsoft YaHei", Arial';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 10, 64);
            const imageData = ctx.getImageData(0, 0, 512, 128);
            const points = [];
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 128) {
                    const x = (i / 4 % 512 - 256) / 8;
                    const y = -(Math.floor(i / 4 / 512) * 128 - 64) / 8;
                    points.push(new THREE.Vector3(x, y, -15)); // z=-15
                }
            }
            const textPoints = [];
            while (textPoints.length < count) {
                const p = points[Math.floor(Math.random() * points.length)].clone();
                p.multiplyScalar(0.6 + Math.random() * 0.3);
                textPoints.push(p);
            }
            return textPoints.slice(0, count);
        }

        const texts = {
            1: generateTextPoints('小艺', particleCount),
            2: generateTextPoints('小时', particleCount),
            3: generateTextPoints('岁岁如嘉所愿', particleCount)
        };
        let targetPoints = texts[0];
        let currentGesture = 0;
        let scale = 1.0;

        const lerpFactor = 0.05;
        function updateParticles() {
            const pos = geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const target = targetPoints[i].clone().multiplyScalar(scale);
                pos[i * 3] += (target.x - pos[i * 3]) * lerpFactor;
                pos[i * 3 + 1] += (target.y - pos[i * 3 + 1]) * lerpFactor;
                pos[i * 3 + 2] += (target.z - pos[i * 3 + 2]) * lerpFactor;

                if (currentGesture === 0) {
                    pos[i * 3] += velocities[i * 3];
                    pos[i * 3 + 1] += velocities[i * 3 + 1];
                    pos[i * 3 + 2] += velocities[i * 3 + 2];
                    if (Math.abs(pos[i * 3]) > 20) velocities[i * 3] *= -1;
                    if (Math.abs(pos[i * 3 + 1]) > 20) velocities[i * 3 + 1] *= -1;
                    if (Math.abs(pos[i * 3 + 2] + 20) > 10) velocities[i * 3 + 2] *= -1;
                }
            }
            geometry.attributes.position.needsUpdate = true;
        }

        // MediaPipe部分不变（摄像头、手势）
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        async function requestCameraPermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });
                videoElement.srcObject = stream;
                videoElement.play();
                console.log('摄像头启动');
                errorDiv.textContent = '';
                return true;
            } catch (err) {
                console.error('摄像头错误:', err);
                errorDiv.textContent = `摄像头失败: ${err.name}`;
                return false;
            }
        }

        let cameraStarted = false;
        function onResults(results) {
            if (results.multiHandLandmarks) {
                let gesture = 0;
                let openness = 0;

                results.multiHandLandmarks.forEach((landmarks) => {
                    const thumb = landmarks[4];
                    const pinky = landmarks[20];
                    const handOpenness = Math.sqrt(
                        Math.pow(thumb.x - pinky.x, 2) + Math.pow(thumb.y - pinky.y, 2)
                    );
                    openness += handOpenness;

                    let fingerCount = 0;
                    const fingers = [
                        { tip: 8, pip: 6 },
                        { tip: 12, pip: 10 },
                        { tip: 16, pip: 14 },
                        { tip: 20, pip: 18 }
                    ];
                    fingers.forEach(f => {
                        if (landmarks[f.tip].y < landmarks[f.pip].y) fingerCount++;
                    });
                    if (landmarks[4].x > landmarks[0].x) fingerCount++;

                    if (fingerCount === 1) gesture = Math.max(gesture, 1);
                    else if (fingerCount === 2) gesture = Math.max(gesture, 2);
                    else if (fingerCount >= 3) gesture = Math.max(gesture, 3);
                });

                if (gesture !== currentGesture) {
                    currentGesture = gesture;
                    if (gesture > 0) targetPoints = texts[gesture];
                }

                scale = Math.max(0.5, Math.min(2.0, 0.5 + (openness / 2) * 1.5));
            }
        }

        async function initCamera() {
            const hasPermission = await requestCameraPermission();
            if (hasPermission && !cameraStarted) {
                const mpCamera = new Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 640,
                    height: 480
                });
                mpCamera.start();
                cameraStarted = true;
            }
        }

        window.addEventListener('load', initCamera);

        function animate() {
            requestAnimationFrame(animate);
            updateParticles();
            box.rotation.x += 0.01; // 盒子旋转，易观察
            box.rotation.y += 0.01;
            particles.rotation.y += 0.001;
            camera.position.z = 15 + Math.sin(Date.now() * 0.001) * 2;
            renderer.render(scene, camera);
            if (Date.now() % 1000 < 16) {
                console.log('渲染: calls=', renderer.info.render.calls, 'pixelRatio=', renderer.getPixelRatio());
                debugDiv.textContent = `粒子: \( {particleCount} | WebGL: 1 | 像素比: \){renderer.getPixelRatio().toFixed(1)} | 盒子测试: 可见?`;
            }
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        });
    </script>
</body>
</html>
