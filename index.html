<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D星空粒子交互系统</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #video { position: absolute; top: 0; left: 0; width: 320px; height: 240px; opacity: 1.0; z-index: 1; border: 2px solid white; } /* 临时满亮+边框测试 */
        #error { position: absolute; top: 10px; right: 10px; color: red; z-index: 2; font-family: Arial; }
        #debug { position: absolute; bottom: 10px; left: 10px; color: white; z-index: 2; font-family: Arial; font-size: 12px; }
    </style>
</head>
<body>
    <video id="video" autoplay muted playsinline></video>
    <div id="error"></div>
    <div id="debug"></div>
    <canvas id="canvas"></canvas>

    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script>
        const videoElement = document.getElementById('video');
        const errorDiv = document.getElementById('error');
        const debugDiv = document.getElementById('debug');
        const canvasElement = document.getElementById('canvas');

        // WebGL1上下文（避WebGL2安卓bug）
        const gl = canvasElement.getContext('webgl', { alpha: false, antialias: false });
        if (!gl) {
            errorDiv.textContent = 'WebGL失败！试Firefox。';
        }

        const renderer = new THREE.WebGLRenderer({ 
            canvas: canvasElement, 
            context: gl,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(1.0); // 固定1.0，防DPI缩水
        renderer.setClearColor(0x000011);
        renderer.logarithmicDepthBuffer = false; // 明确禁用，防近物隐藏
        renderer.gammaOutput = true; // 颜色校正

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000); // near=0.01防剔除
        camera.position.z = 10;

        // 测试盒子（无透明，基础材质）
        const boxGeometry = new THREE.BoxGeometry(6, 6, 6);
        const boxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const box = new THREE.Mesh(boxGeometry, boxMaterial);
        box.position.set(0, 0, -3);
        scene.add(box);

        // 粒子（无透明/混合，sizeAttenuation=true防frustum消失）
        const particleCount = 1000; // 减低内存
        const positions = new Float32Array(particleCount * 3);
        const velocities = new Float32Array(particleCount * 3);
        const geometry = new THREE.BufferGeometry();
        const material = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 8.0, // 大size
            sizeAttenuation: true, // 启用衰减，但相机近
            transparent: false, // 移除透明，避Z-fighting
            opacity: 1.0,
            blending: THREE.NormalBlending // 无特殊混合
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // 初始化粒子（超近相机前）
        for (let i = 0; i < particleCount; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 30;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 30;
            positions[i * 3 + 2] = -2 - Math.random() * 8; // z: -2 to -10
            velocities[i * 3] = (Math.random() - 0.5) * 0.05;
            velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.05;
            velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.03;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // 文字点云（z近）
        function generateTextPoints(text, count) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 60px "Microsoft YaHei", Arial';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 10, 64);
            const imageData = ctx.getImageData(0, 0, 512, 128);
            const points = [];
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 128) {
                    const x = (i / 4 % 512 - 256) / 6;
                    const y = -(Math.floor(i / 4 / 512) * 128 - 64) / 6;
                    points.push(new THREE.Vector3(x, y, -5)); // z=-5
                }
            }
            const textPoints = [];
            while (textPoints.length < count) {
                const p = points[Math.floor(Math.random() * points.length)].clone();
                p.multiplyScalar(0.5 + Math.random() * 0.3);
                textPoints.push(p);
            }
            return textPoints.slice(0, count);
        }

        const texts = {
            1: generateTextPoints('小艺', particleCount),
            2: generateTextPoints('小时', particleCount),
            3: generateTextPoints('岁岁如嘉所愿', particleCount)
        };
        let targetPoints = texts[0];
        let currentGesture = 0;
        let scale = 1.0;

        const lerpFactor = 0.05;
        function updateParticles() {
            const pos = geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const target = targetPoints[i].clone().multiplyScalar(scale);
                pos[i * 3] += (target.x - pos[i * 3]) * lerpFactor;
                pos[i * 3 + 1] += (target.y - pos[i * 3 + 1]) * lerpFactor;
                pos[i * 3 + 2] += (target.z - pos[i * 3 + 2]) * lerpFactor;

                if (currentGesture === 0) {
                    pos[i * 3] += velocities[i * 3];
                    pos[i * 3 + 1] += velocities[i * 3 + 1];
                    pos[i * 3 + 2] += velocities[i * 3 + 2];
                    if (Math.abs(pos[i * 3]) > 15) velocities[i * 3] *= -1;
                    if (Math.abs(pos[i * 3 + 1]) > 15) velocities[i * 3 + 1] *= -1;
                    if (Math.abs(pos[i * 3 + 2] + 6) > 4) velocities[i * 3 + 2] *= -1;
                }
            }
            geometry.attributes.position.needsUpdate = true;
        }

        // MediaPipe（简化，强制重试权限）
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 0, // 低复杂度，防安卓卡
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        async function requestCameraPermission() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });
                videoElement.srcObject = stream;
                await videoElement.play();
                console.log('摄像头OK');
                errorDiv.textContent = '';
                return true;
            } catch (err) {
                console.error('摄像头:', err);
                errorDiv.textContent = `摄像头: ${err.name}. 设置>Chrome>权限允许。`;
                // 重试按钮提示
                setTimeout(() => alert('点击重试: 允许摄像头'), 1000);
                return false;
            }
        }

        let cameraStarted = false;
        function onResults(results) {
            if (results.multiHandLandmarks) {
                let gesture = 0;
                let openness = 0;
                results.multiHandLandmarks.forEach((landmarks) => {
                    const thumb = landmarks[4];
                    const pinky = landmarks[20];
                    openness += Math.sqrt((thumb.x - pinky.x)**2 + (thumb.y - pinky.y)**2);

                    let fingerCount = 0;
                    const fingers = [{tip:8,pip:6},{tip:12,pip:10},{tip:16,pip:14},{tip:20,pip:18}];
                    fingers.forEach(f => { if (landmarks[f.tip].y < landmarks[f.pip].y) fingerCount++; });
                    if (landmarks[4].x > landmarks[0].x) fingerCount++;

                    if (fingerCount === 1) gesture = 1;
                    else if (fingerCount === 2) gesture = 2;
                    else if (fingerCount >= 3) gesture = 3;
                });

                if (gesture !== currentGesture) {
                    currentGesture = gesture;
                    if (gesture > 0) targetPoints = texts[gesture];
                }
                scale = Math.max(0.5, Math.min(2.0, 0.5 + openness * 1.5));
            }
        }

        async function initCamera() {
            const hasPermission = await requestCameraPermission();
            if (hasPermission && !cameraStarted) {
                const mpCamera = new Camera(videoElement, {
                    onFrame: async () => await hands.send({image: videoElement}),
                    width: 640,
                    height: 480
                });
                mpCamera.start();
                cameraStarted = true;
            }
        }

        window.addEventListener('load', initCamera);

        function animate() {
            requestAnimationFrame(animate);
            updateParticles();
            box.rotation.x += 0.01;
            box.rotation.y += 0.01;
            particles.rotation.y += 0.001;
            camera.position.z = 10 + Math.sin(Date.now() * 0.001) * 1;
            renderer.render(scene, camera);
            if (Date.now() % 1000 < 16) {
                console.log('渲染: calls=', renderer.info.render.calls || 0, 'pixelRatio=1.0');
                debugDiv.textContent = `粒子: \( {particleCount} | WebGL:1 | 盒子/点可见? | 摄像头: \){videoElement.srcObject ? 'OK' : '无'}`;
            }
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1.0);
        });
    </script>
</body>
</html>
